<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>High Performance Computing 2 | Algorithmic Time: Energy and Power &mdash; serenefield-sphinx  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="High Performance Computing 3 | I/O Avoiding Algorithms" href="note3.html" />
    <link rel="prev" title="High Performance Computing 1 | Memory Locality Theory" href="note1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            serenefield-sphinx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">DevOps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devops/index.html">⛴️  Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devops/index.html#ckad">☸️  CKAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devops/index.html#advanced-k8s">⛵️  Advanced K8s</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devops/index.html#apache-solr">🥐  Apache Solr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devops/index.html#hadoop-ecosystem">🐘  Hadoop Ecosystem</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Japanese</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Jap/index.html">🏯  N5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Jap/index.html#n4">🏯  N4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Jap/index.html#id1">🎶  音楽</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guitar</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Guitar/index.html">🎸  Level 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Guitar/index.html#level-2">🎸  Level 2</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">OMSCS</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">💻  Computer Network</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html#high-performance-computing">💻  High Performance Computing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="note1.html">High Performance Computing 1 | Memory Locality Theory</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">High Performance Computing 2 | Algorithmic Time: Energy and Power</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#speed-and-time">1. Speed and Time</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#speed-trend">(1) Speed Trend</a></li>
<li class="toctree-l4"><a class="reference internal" href="#speed-limits">(2) Speed Limits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recall-machine-balance">(3) Recall: Machine Balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computational-cost-and-transistor-density">(4) Computational Cost and Transistor Density</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfer-cost-and-stream">(5) Transfer Cost and Stream</a></li>
<li class="toctree-l4"><a class="reference internal" href="#machine-balance-doubling-time">(6) Machine Balance Doubling Time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#machine-balance-principle">(7) Machine Balance Principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algorithm-goal-and-system-goal">(8) Algorithm Goal and System Goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#doubling-issue">(9) Doubling Issue</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#power">2. Power</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-power">(1) Definition of Power</a></li>
<li class="toctree-l4"><a class="reference internal" href="#components-of-power">(2) Components of Power</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-power-equation">(3) Dynamic Power Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dvfs-example">(4) DVFS Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metrics-we-have">(5) Metrics We Have</a></li>
<li class="toctree-l4"><a class="reference internal" href="#best-metric-for-energy">(6) Best Metric for Energy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#best-metric-for-dynamic-power">(7) Best Metric for Dynamic Power</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="note3.html">High Performance Computing 3 | I/O Avoiding Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="note4.html">High Performance Computing 4｜Cache Oblivious Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="note5.html">High Performance Computing 5 | Work Span Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="note7.html">High Performance Computing 7 | Scan and Rank List</a></li>
<li class="toctree-l2"><a class="reference internal" href="note8.html">High Performance Computing 8 | Parallel on Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="note9.html">High Performance Computing 9 | Midterm Review</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../index.html#information-security">💻  Information Security</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Arts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Arts/index.html">🖼️  Drawing - Perspective</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Arts/index.html#blender-basic">🧊  Blender - Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Arts/index.html#blender-anime">🎥  Blender - Anime</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tests</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tests/index.html">🧪  Sphinx Tests</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">serenefield-sphinx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">💻  Computer Network</a></li>
      <li class="breadcrumb-item active">High Performance Computing 2 | Algorithmic Time: Energy and Power</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/OMSCS/HPC/note2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="high-performance-computing-2-algorithmic-time-energy-and-power">
<h1>High Performance Computing 2 | Algorithmic Time: Energy and Power<a class="headerlink" href="#high-performance-computing-2-algorithmic-time-energy-and-power" title="Permalink to this heading"></a></h1>
<section id="speed-and-time">
<h2>1. Speed and Time<a class="headerlink" href="#speed-and-time" title="Permalink to this heading"></a></h2>
<section id="speed-trend">
<h3>(1) Speed Trend<a class="headerlink" href="#speed-trend" title="Permalink to this heading"></a></h3>
<p>As a part of Danny Hillis’ thesis, let’s consider a processor that can execute about 100 billion operations per second (<code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">Giga</span> <span class="pre">ops/s</span></code>) in the best case and this is called the peak throughput today. Let’s also assume that this performance doubled in every 2 years and now let’s consider how fast a processor will be in 10 years.</p>
<p>The answer is about 3 Tera ops/s. It can be calculated through,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">100</span> <span class="n">Giga</span> <span class="n">ops</span><span class="o">/</span><span class="n">s</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">^</span> <span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3200</span> <span class="n">Gops</span><span class="o">/</span><span class="n">s</span> <span class="o">=</span> <span class="mf">3.2</span> <span class="n">Tops</span><span class="o">/</span><span class="n">s</span>
</pre></div>
</div>
</section>
<section id="speed-limits">
<h3>(2) Speed Limits<a class="headerlink" href="#speed-limits" title="Permalink to this heading"></a></h3>
<p>And we should also think about the speed limits. Suppose we have a 2D mesh of physical processors which has many cores that firs on a physical die of a certain size of <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">by</span> <span class="pre">l</span></code>.</p>
<p>Also, in this mesh, each core is connected to its 8 nearest neighbours like the following plot and this means each processing unit can communite along its diagonal routes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>          <span class="o">|</span>        <span class="o">|</span>       <span class="o">|</span>
      <span class="o">---</span> <span class="o">*</span> <span class="o">------</span> <span class="o">*</span> <span class="o">-----</span> <span class="o">*</span> <span class="o">---</span>
          <span class="o">|</span>   \    <span class="o">|</span>    <span class="o">/</span>  <span class="o">|</span>
          <span class="o">|</span>    \   <span class="o">|</span>   <span class="o">/</span>   <span class="o">|</span>
      <span class="o">---</span> <span class="o">*</span> <span class="o">------</span> <span class="o">*</span> <span class="o">-----</span> <span class="o">*</span> <span class="o">---</span>
          <span class="o">|</span>    <span class="o">/</span>   <span class="o">|</span>   \   <span class="o">|</span>
          <span class="o">|</span>   <span class="o">/</span>    <span class="o">|</span>    \  <span class="o">|</span>
      <span class="o">---</span> <span class="o">*</span> <span class="o">------</span> <span class="o">*</span> <span class="o">-----</span> <span class="o">*</span> <span class="o">---</span>
          <span class="o">|</span>        <span class="o">|</span>       <span class="o">|</span>
</pre></div>
</div>
<p>If a single operation defines as to start from at the processsing unit at the center and the operation then travels as a signal to a unit at one of the corners, it then goes back and make it a round trip. If we want to do 3 Tops/s (also <code class="docutils literal notranslate"><span class="pre">3*10^12</span> <span class="pre">ops/s</span></code>) sequentially, then what is the upper bound of <code class="docutils literal notranslate"><span class="pre">l</span></code> that we can have? Assuming the light speed is 3*10^8 m/s.</p>
<p>To solve this problem, let’s have the following calculation. Suppose we execute 1 operation and the distance it should travel is a round trip of the half diagonal, so,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">l</span>
</pre></div>
</div>
<p>The light speed is the fastest speed we can achieve, so</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">/</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">c</span>
</pre></div>
</div>
<p>And the time we have here should be the time of executing 1 operation under the current performance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">P</span>
</pre></div>
</div>
<p>So we have,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dP</span> <span class="o">&lt;=</span> <span class="n">c</span>
</pre></div>
</div>
<p>Then,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="n">lP</span> <span class="o">&lt;=</span> <span class="n">c</span>
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="n">P</span><span class="p">)</span> <span class="o">=</span> <span class="mf">7e-5</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">70</span> <span class="n">µm</span>
</pre></div>
</div>
</section>
<section id="recall-machine-balance">
<h3>(3) Recall: Machine Balance<a class="headerlink" href="#recall-machine-balance" title="Permalink to this heading"></a></h3>
<p>Let’s recall what we have discussed in the last lesson. We have,</p>
<ul class="simple">
<li><p>Computational Cost: <code class="docutils literal notranslate"><span class="pre">T_comp</span> <span class="pre">=</span> <span class="pre">τW</span></code></p></li>
<li><p>Transfer Cost: <code class="docutils literal notranslate"><span class="pre">T_mem</span> <span class="pre">=</span> <span class="pre">ɑLQ</span></code></p></li>
</ul>
<p>where τ is related to the processor and it means the processor can process <code class="docutils literal notranslate"><span class="pre">τ</span></code> operations per second. And <code class="docutils literal notranslate"><span class="pre">ɑ</span></code> is the rate of transfering the data between the slow and fast memory, and it means we can have <code class="docutils literal notranslate"><span class="pre">ɑ</span></code> words transferred in a time unit.</p>
<p>Then the machine balance is defined by,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">τ</span> <span class="o">/</span> <span class="n">ɑ</span>
</pre></div>
</div>
<p>And it has a unit of operations per word.</p>
</section>
<section id="computational-cost-and-transistor-density">
<h3>(4) Computational Cost and Transistor Density<a class="headerlink" href="#computational-cost-and-transistor-density" title="Permalink to this heading"></a></h3>
<p>The cost of this computation τ is related to the transistor density, which is defined by the number of transistors that can fit in a given amount of space. In the last 40 years, the transistors that can be fitted in a given area has increased by a factor about a million. The performance of computation density doubles roughly every <code class="docutils literal notranslate"><span class="pre">1.9</span></code> years.</p>
</section>
<section id="transfer-cost-and-stream">
<h3>(5) Transfer Cost and Stream<a class="headerlink" href="#transfer-cost-and-stream" title="Permalink to this heading"></a></h3>
<p>Similar to the transistor density, there’s also a benchmark called steam that measures the growth of transfer cost. Statistically, it shows that the <code class="docutils literal notranslate"><span class="pre">ɑ</span></code> has essentially doubled once every <code class="docutils literal notranslate"><span class="pre">2.9</span></code> years.</p>
</section>
<section id="machine-balance-doubling-time">
<h3>(6) Machine Balance Doubling Time<a class="headerlink" href="#machine-balance-doubling-time" title="Permalink to this heading"></a></h3>
<p>Now, let’s do some calculations based on the information we have. Suppose we have <code class="docutils literal notranslate"><span class="pre">τ</span></code> doubled in 1.9 years and <code class="docutils literal notranslate"><span class="pre">ɑ</span></code> doubled in 2.9 years. Then how many years do we need if we want to double the machine balance <code class="docutils literal notranslate"><span class="pre">B</span></code>?</p>
<p>To solve this question, let’s first assume that we can get <code class="docutils literal notranslate"><span class="pre">B</span></code> doubled in <code class="docutils literal notranslate"><span class="pre">t</span></code> years. Then</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">τ2</span><span class="o">^</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mf">1.9</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">ɑ2</span><span class="o">^</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mf">2.9</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="n">τ</span><span class="o">/</span><span class="n">ɑ</span>
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">τ</span><span class="o">/</span><span class="n">ɑ</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mf">1.9</span> <span class="o">-</span> <span class="n">T</span><span class="o">/</span><span class="mf">2.9</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">τ</span><span class="o">/</span><span class="n">ɑ</span>
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mf">1.9</span> <span class="o">-</span> <span class="n">T</span><span class="o">/</span><span class="mf">2.9</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Therefore,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">/</span><span class="mf">1.9</span> <span class="o">-</span> <span class="n">T</span><span class="o">/</span><span class="mf">2.9</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Times 1.9 * 2.9 on both sides, then,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="mf">1.9</span> <span class="o">*</span> <span class="mf">2.9</span> <span class="o">=</span> <span class="mf">5.51</span>
</pre></div>
</div>
</section>
<section id="machine-balance-principle">
<h3>(7) Machine Balance Principle<a class="headerlink" href="#machine-balance-principle" title="Permalink to this heading"></a></h3>
<p>In the case above, we can confirm that the rate of improvement in computation far outstrips the rate of improvement in communication. So for an algorithm, it may be better to trade off more computation with less communication.</p>
<p>Suppose we have the following notations,</p>
<ul class="simple">
<li><p>Work: W = W(n) = total ops</p></li>
<li><p>Span/Critical Path Length: D = D(n) = critical ops</p></li>
<li><p>Processing Cores on Processor: P</p></li>
<li><p>Theoritical Transactions: Q = Q(n;Z,L)</p></li>
</ul>
<p>And we will also assume W includes the count of Q, so</p>
<ul class="simple">
<li><p>Q &lt;= W</p></li>
</ul>
<p>Let’s also assume that each core can execute some number of operations per unit time <code class="docutils literal notranslate"><span class="pre">R_0</span></code> (note that R here is simliar to <code class="docutils literal notranslate"><span class="pre">τ</span></code>), and each transaction initiates a data transfer across the <code class="docutils literal notranslate"><span class="pre">L</span></code> wires in parallel and the time it takes to go across a wire is <code class="docutils literal notranslate"><span class="pre">β_0</span></code>.</p>
<p>Recall that because both <code class="docutils literal notranslate"><span class="pre">R_0</span></code> and <code class="docutils literal notranslate"><span class="pre">β_0</span></code> are dependent to the machine, we usually ignore these costs while calculating W, Q, and D, and this is called the <strong>unit cost</strong> because we are assuming unit cost operations. However, in the HPC setting, we have to take <code class="docutils literal notranslate"><span class="pre">R_0</span></code> and <code class="docutils literal notranslate"><span class="pre">β_0</span></code> into consideration for the <strong>real cost</strong> to see what they imply for the overall system.</p>
<p>To transfer a model of unit cost to real cost, we can account for non-unit const by transforming a unit cost DAG to a non-unit cost DAG. Suppose this node is one of the compute operations and executing it cost <code class="docutils literal notranslate"><span class="pre">1/R_0</span></code> time units as follows,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       cost: 1/R_0
           ↓
... -----&gt; * ------&gt; ....
           \
            ...
</pre></div>
</div>
<p>Then we can replace this single unit cost node with a sequence of <code class="docutils literal notranslate"><span class="pre">1/R_0</span></code> unit-cost vertices,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>           | ------ 1/R_0 nodes ------- |
           |                            |
        cost: 1  cost: 1    cost: 1  cost: 1
           ↓        ↓          ↓        ↓
... -----&gt; * -----&gt; * --...--&gt; * -----&gt; * ------&gt; ....
                                      \
                                       ...
</pre></div>
</div>
<p>Next, let’s also say that the words of the memory transaction can be in flat corrently with compute operations. In terms of DAGs, there’s additional set of <code class="docutils literal notranslate"><span class="pre">L/β_0</span></code> fully concurrent nodes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       cost: 1/R_0
           ↓
... ------&gt; * ------&gt; ....   ---+
    |               |           |
... +-----&gt; * ------+ ....      |
    |               |           |
           ...             L/β_0 nodes
    |               |           |
... +-----&gt; * ------+ ....      |
    |               |           |
... +-----&gt; * ------+ ....   ---+
</pre></div>
</div>
<p>So now let’s consider the best case execution time for this DAG. We have the following calcuations,</p>
<ul class="simple">
<li><p><strong>Usual work</strong> only scaled by processor speed: <code class="docutils literal notranslate"><span class="pre">W/(PR_0)</span></code></p></li>
<li><p><strong>Span locks</strong> only scaled by processor speed: <code class="docutils literal notranslate"><span class="pre">D/R_0</span></code></p></li>
</ul>
<p>There’s also one extra cost to do the communications so for each transaction, we have to pay for the <code class="docutils literal notranslate"><span class="pre">L/β_0</span></code> nodes. So,</p>
<ul class="simple">
<li><p><strong>Communication cost</strong>: <code class="docutils literal notranslate"><span class="pre">QL/β_0</span></code></p></li>
</ul>
<p>Because these times are fully overlapped in the best case, then we have the best case execution time as,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T_p</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="p">(</span><span class="n">PR_0</span><span class="p">),</span> <span class="n">D</span><span class="o">/</span><span class="n">R_0</span><span class="p">,</span> <span class="n">QL</span><span class="o">/</span><span class="n">β_0</span><span class="p">)</span>
</pre></div>
</div>
<p>Assume we have done a good job of designing the algorithm, the critical path should be short. So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">&lt;&lt;</span> <span class="n">W</span> <span class="o">/</span> <span class="n">P</span>
</pre></div>
</div>
<p>Therefore,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">D</span><span class="o">/</span><span class="n">R_0</span> <span class="o">&lt;&lt;</span> <span class="n">W</span><span class="o">/</span><span class="p">(</span><span class="n">PR_0</span><span class="p">)</span>
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T_p</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">W</span><span class="o">/</span><span class="p">(</span><span class="n">PR_0</span><span class="p">),</span> <span class="n">QL</span><span class="o">/</span><span class="n">β_0</span><span class="p">)</span>
</pre></div>
</div>
<p>So in this case, when the right hand side is minimized, that means we need to have <code class="docutils literal notranslate"><span class="pre">W/(PR_0)</span> <span class="pre">=</span> <span class="pre">QL/β_0</span></code>. But to think about the historical growth rate trend, if we want to benefit from transistor scaling, then we need the compute time to dominate the communication time. This is what we called the <strong>principle of balance</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">W</span><span class="o">/</span><span class="p">(</span><span class="n">PR_0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">QL</span><span class="o">/</span><span class="n">β_0</span>
</pre></div>
</div>
</section>
<section id="algorithm-goal-and-system-goal">
<h3>(8) Algorithm Goal and System Goal<a class="headerlink" href="#algorithm-goal-and-system-goal" title="Permalink to this heading"></a></h3>
<p>We can also write this inequation as follows,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">W</span><span class="o">/</span><span class="n">Q</span> <span class="o">&gt;=</span> <span class="n">R_0</span><span class="o">/</span><span class="n">β_0</span> <span class="o">*</span> <span class="n">PL</span>
</pre></div>
</div>
<p>So this inequation indicates that on the algorithm side, we should make the left side <code class="docutils literal notranslate"><span class="pre">W/Q</span></code> <strong>as large as possible</strong> because the right side is subject to inevitable scaling trends that cause it to grow over time. On the system side, the goal is to try to keep <code class="docutils literal notranslate"><span class="pre">R_0/β_0</span> <span class="pre">*</span> <span class="pre">PL</span></code> as small as possible to help the algorithms people out.</p>
</section>
<section id="doubling-issue">
<h3>(9) Doubling Issue<a class="headerlink" href="#doubling-issue" title="Permalink to this heading"></a></h3>
<p>Now let’s see an example. Suppose we have a machine that is perfectly balanced for sorting large arrays. Then how can you maintain balance if the number of cores doubles? Let’s assume that for sorting, the best case ratio of <code class="docutils literal notranslate"><span class="pre">W/Q</span></code> should be,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">W</span><span class="o">/</span><span class="n">Q</span> <span class="o">~</span> <span class="n">L</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>We call <code class="docutils literal notranslate"><span class="pre">β_0</span></code> the bandwith (of the wires) and <code class="docutils literal notranslate"><span class="pre">R_0</span></code> the peak (of the processors). And in this example, we have,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">R_0</span><span class="o">/</span><span class="n">β_0</span> <span class="o">*</span> <span class="n">P</span>
</pre></div>
</div>
<p>So here are some possible answers,</p>
<ul class="simple">
<li><p>Square both the fast memory size <code class="docutils literal notranslate"><span class="pre">Z</span></code> and transaction size <code class="docutils literal notranslate"><span class="pre">L</span></code></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="o">^</span><span class="mi">2</span><span class="o">/</span><span class="n">L</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">R_0</span><span class="o">/</span><span class="n">β_0</span> <span class="o">*</span> <span class="mi">2</span><span class="n">P</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Double the bandwidth</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">R_0</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="n">β_0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="n">P</span> <span class="o">=</span> <span class="n">R_0</span><span class="o">/</span><span class="n">β_0</span> <span class="o">*</span> <span class="n">P</span>
</pre></div>
</div>
</section>
</section>
<section id="power">
<h2>2. Power<a class="headerlink" href="#power" title="Permalink to this heading"></a></h2>
<section id="definition-of-power">
<h3>(1) Definition of Power<a class="headerlink" href="#definition-of-power" title="Permalink to this heading"></a></h3>
<p>Power is defined by the energy consumed in the unit time,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">E</span> <span class="o">/</span> <span class="n">T</span>
</pre></div>
</div>
<p>Because increasing the clock frequency makes the power consumption skyrocket, that’s why we use multicores.</p>
</section>
<section id="components-of-power">
<h3>(2) Components of Power<a class="headerlink" href="#components-of-power" title="Permalink to this heading"></a></h3>
<p>The power of a computing system has two parts,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">P_0</span> <span class="o">+</span> <span class="n">ΔP</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">P_0</span></code> is the constant power (or static power or idle power), which is what you pay just to keep the system on. <code class="docutils literal notranslate"><span class="pre">ΔP</span></code> is the dynamic power and that is what you pay beyond the constant power when the program is running.</p>
</section>
<section id="dynamic-power-equation">
<h3>(3) Dynamic Power Equation<a class="headerlink" href="#dynamic-power-equation" title="Permalink to this heading"></a></h3>
<p>Now let’s suppose we have a gate and <code class="docutils literal notranslate"><span class="pre">C</span></code> is the capacitance of this gate and <code class="docutils literal notranslate"><span class="pre">V</span></code> is the supply voltage. Then the energy consumed by this gate while switching is,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">CV</span><span class="o">^</span><span class="mi">2</span>
</pre></div>
</div>
<p>The <strong>frequency</strong> or the <strong>clock rate</strong> <code class="docutils literal notranslate"><span class="pre">f</span></code> of this circuit is the maximum number of cycles per unit time. However, the gate doesn’t necessarily switch on every cycle and it might happen only once ever few cycles. So <strong>activity factor</strong> <code class="docutils literal notranslate"><span class="pre">a</span></code> is the number of switches per cycle (&lt;= 1).</p>
<p>Then taken together, these parameters tell us how to compute dynamic power.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ΔP</span> <span class="o">=</span> <span class="n">CV</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>
</pre></div>
</div>
<p>Before moving on, there’s one more quick fact about this. The clock rate <code class="docutils literal notranslate"><span class="pre">f</span></code> and the supply voltage <code class="docutils literal notranslate"><span class="pre">V</span></code> need to be kept in proportion to one another. And this is necessary to maintaining the stability and reliability of the circuit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f ∝ V
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code>, and <code class="docutils literal notranslate"><span class="pre">a</span></code> are all changable by systems or algorithms. <code class="docutils literal notranslate"><span class="pre">V</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code> can be changed through dynamic voltage and frequency scaling (DVFS, or cpufreq for Linux). <code class="docutils literal notranslate"><span class="pre">a</span></code> can be improved by turning of the chunks we don’t necessary need.</p>
</section>
<section id="dvfs-example">
<h3>(4) DVFS Example<a class="headerlink" href="#dvfs-example" title="Permalink to this heading"></a></h3>
<p>Suppose we have two systems A and B, and</p>
<ul class="simple">
<li><p>Energy: E_B = 2 E_A</p></li>
<li><p>Time: T_B = 1/3 T_A</p></li>
</ul>
<p>Now if we use DVFS to rescale B so that it’s power matches A. So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P_B</span> <span class="o">=</span> <span class="n">E_B</span> <span class="o">/</span> <span class="n">T_B</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">E_A</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="n">T_A</span><span class="p">)</span> <span class="o">=</span> <span class="mi">6</span> <span class="n">P_A</span>
</pre></div>
</div>
<p>For,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>P ∝ f^3
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f_B</span> <span class="o">=</span> <span class="mi">6</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="n">f_A</span>
</pre></div>
</div>
<p>Also,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>T ∝ 1/f
</pre></div>
</div>
<p>So,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T_B</span><span class="s1">&#39; / T_A = f_A / f_B = 1 / 6^(1/3) &lt; 1</span>
</pre></div>
</div>
<p>So</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T_B</span><span class="s1">&#39; &lt; T_A</span>
</pre></div>
</div>
<p>Therefore, B is still faster than A.</p>
</section>
<section id="metrics-we-have">
<h3>(5) Metrics We Have<a class="headerlink" href="#metrics-we-have" title="Permalink to this heading"></a></h3>
<p>To measure different energies, now we have several metrics.</p>
<ul class="simple">
<li><p>Total work: <code class="docutils literal notranslate"><span class="pre">W</span> <span class="pre">=</span> <span class="pre">W(n)</span></code></p></li>
<li><p>Span: <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">D(n)</span></code></p></li>
<li><p>Average available Parallelism: <code class="docutils literal notranslate"><span class="pre">W/D</span></code></p></li>
<li><p>Time for <code class="docutils literal notranslate"><span class="pre">P</span></code> processors: <code class="docutils literal notranslate"><span class="pre">max(D,</span> <span class="pre">W/P)</span> <span class="pre">&lt;=</span> <span class="pre">T_P</span> <span class="pre">&lt;=</span> <span class="pre">D</span> <span class="pre">+</span> <span class="pre">(W-D)/P</span></code></p></li>
<li><p>Self-speedup: <code class="docutils literal notranslate"><span class="pre">S_P</span> <span class="pre">=</span> <span class="pre">T_1</span> <span class="pre">/</span> <span class="pre">T_P</span></code> which means time on a single-core processor devided by time on a processor with <code class="docutils literal notranslate"><span class="pre">P</span></code> cores</p></li>
</ul>
</section>
<section id="best-metric-for-energy">
<h3>(6) Best Metric for Energy<a class="headerlink" href="#best-metric-for-energy" title="Permalink to this heading"></a></h3>
<p>The best metric for energy is the work <code class="docutils literal notranslate"><span class="pre">W</span></code> because energy is paied for each operation,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">eW</span>
</pre></div>
</div>
</section>
<section id="best-metric-for-dynamic-power">
<h3>(7) Best Metric for Dynamic Power<a class="headerlink" href="#best-metric-for-dynamic-power" title="Permalink to this heading"></a></h3>
<p>The best metric for the dynamic power if we ignore the constant power and assume constant energy per operation is the <strong>self-speedup</strong>. Let’s see why.</p>
<p>The dynamic power should be defined as,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Power</span> <span class="o">=</span> <span class="n">Energy</span> <span class="o">/</span> <span class="n">Time</span>
</pre></div>
</div>
<p>And the total energy we need for our algorithm is in proportion to the time we spend on a single-core processor. And the time we spend here is equal to the time we spend on this P-core system. So in this case that we can figure out self-speedup is a good metric.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="note1.html" class="btn btn-neutral float-left" title="High Performance Computing 1 | Memory Locality Theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="note3.html" class="btn btn-neutral float-right" title="High Performance Computing 3 | I/O Avoiding Algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Yufeng Xing.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>